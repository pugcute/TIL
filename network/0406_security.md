# 0406 정보보안





## 전송 계층 보안 - SSH, TLS



1. SSL -1994년 넷스케이프사의 웹 브라우저를 위한 프로토콜
2. 목적 - tcp 기반의 어플리케이션에 대한 종단 간 보안서비스를 제공
3. 기밀성, 무결성, 인증을 제공/ 
4. 계층 구조 - 상위계층(handshake, change cipher spec, alert)/ 하위계층(record)

중요  - handshake 프로토콜 : 종단 간에 보안 파라미터를 협상하기 위한 프로토콜

​			record 프로토콜 : 적용된 보안 파라미터를 이용하여 실제 암호화/복호화, 무결성 보호 등의 기능을 제공하는 프로토콜





## 상세한 프로토콜 설명



### stateful protocol

- 이는 완전 협상을 통해 세션을 생성, 이를 공유하는 다수의 종단 간에 단축협상을 의미

- 대칭 암호 알고리즘(DES, ARIA, AES)과 HMAC(대칭 암호를 이용한 메시지 인증코드)가 주로 사용됨
- 필드는 세션 id, 상대방 인증서(x.509 v3-이를 보아 어느정도 메시지 인증을 보장, 단 금융 시스템에 쓰이는 부인 방지 기능까지는 확답할 수 없음). 암호 명세, 압축 방식, 키 블럭을 생성하기 위해 공유하는 48비트 비밀값인 master secret(키 분배 문제를 이를 통해서 해결- 사전 협상일지라도 대칭키의 암호 분배 문제는 발생하므로). 세션 관련 정보(재사용 여부)
- 상태 정보는 단축 협상을 통해 생성한 32바이트 난수 값인 server random, 서버와 클라이언트이 사용하는 비밀키, 메시지 인증코드를 변환할 때 쓰이는 비밀키(HMAC이므로). HMAC에 쓰이는 블록 암호 모드에 관련된 정보(CFB, CTR같은 블록 모드를 의미), 시퀀스 넘버
- 결론 : 완전 협상을 통해 주고 받은 사전 마스터 비밀키를 조합 - > 마스터 비밀키를 생성 후 세션에 저장 -> 이를 해시하여 키 블럭이 생성 -> 키 블럭이 생성되며 블록 모드와 어떤 암호 알고리즘을 쓸지 정하고 비밀키를 통해 암호화 + server random, client random을 통해 salt도 더함



### 단축 협상



- 클라이언트쪽에서 client hello 메시지를 보냄. 여기에는 세션 id와 client random이 있음
- 서버쪽에서 클라이언트에게 server hello를 보냄. server random 있음
- 이때 서버측에서 클라이언트가 보낸 세션 id정보가 있는 경우 기존 세션 id를 사용하게 되고, 없으면 server hello에 새로운 세션 id를 같이 보냄



### 완전협상(handshake)



- 클라이언트 쪽에서 client hello, 가용할 수 있는 TLS의 버전 정보, 암호 도구 목록, 압축 방식에 관한 정보를 보냄
- 이때 암호도구 목록은 키 교환 및 알고리즘과 암호 명세로 구분
- ex) TLS_RSA_WITH_AEX_128_ECB_SHA192 키 교환 알고리즘은 공개키 인증 방식인 RSA(소인수분해) 사용, AES를 통해 암호화하고 128비트 키 길이, 블록 모드는 ECB 사용, HMAC은 SHA-2 사용/ 보안적으로 권장이기는 하나, 키 길이가 비교적 짧음
- 서버 쪽에서 server hello/ 사용할 암호도구 목록, 압축 방식을 보냄 + 서버랜덤과 세션 id(필수)
- 서버가 클라이언트에게 server certificate를 보냄 - 서버 인증서 목록을 전달(선택)
- 서버가 클라이언트에게 server key exchange 보냄. 키 교환에 관련된 정보인 소수, 원시근 등을 보내는 절차이며, 이를 서명 알고리즘(DSS)를 통해 서명한 후 보냄(만약 서명안하고 보낼 시에 공인된 서버의 정보인지 알 수 없기에) (선택-이는 디피-헬만일 경우는 필수)
- 위에 절차가 모두 끝나면(단, 위 두 개는 필요시에 보냄) server hello done을 보냄
- 클라이언트가 서버에 client key exchange 메시지를 보냄. 이때 사전 마스터 비밀키를 생성하고 서버에 전달. 단, 디피 헬만은 소수와 원시근을 통해 연산한 후 공통의 사전 마스터 비밀키를 만드나(디피-헬만은 기본적으로 공개키라기보다는 대칭키의 교환 알고리즘이므로) RSA 기반의 공개키는 서버 인증서의 공개키로 암호화(즉  서버는 자신의 비밀키를 통해 클라이언트의 사전 마스터 비밀키를 볼 수 있으며 부인방지 모드가 아니라 암호 모드(따라서 직접적으로 부인 방지을 제공한다고 보기 힘듬))
- 좀 더 구체적인 절차는 향후 버퍼슈트쓰겠음.
- 

