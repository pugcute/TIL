## jsx 제한사항

- 컴포넌트에서 반환하는 코드로, 실제 DOM으로 랜더링
- 루트 수준에서 두 개 이상의 요소가 인접해 있으면 예러
- 왜냐 루트 요소는 반드시 하나여야 함
- 자바스크립트에서 return은 항상 하나의 값만 반환하기 때문
- 루트 요소를 하나만 하거나, jsx 코드가 아니라 return 반환값을 배열로 만들거나 하면 해결
- 단 배열로 하면 리액트는 키를 반드시 원하므로 키를 따로 지정해야 함 

- 루트 요소를 하나로 처리하는 방법은 div soup - 리액트 컴포넌트가 많이 중첩될 수 있고, 계속 div로 감싸게 될 수 있음(의미 없고 제한 사항으로 넣는 경우가 많음)
- 불필요한 div 요소가 많이 생길 수밖에 없음, 스타일링을 힘들게 할 수 있음



## wrapper

- fragment 가 wrapper 역할을 수행, 빈 wrapper을 반환  ==> <>, <React.Fragment>
- Portals => 오버레이 요소가 dom에 중첩된 경우나, div에 이벤트핸들러가 걸린 경우는 좋지 않음, 즉 오버레이 요소가 중첩 안되게 하는 것이 목적
- 컴포넌트 이동시킬 장소와 이를 가져와야 한다는 것을 명시해야 함
- refs  다른 dom요소에서 접근해서 작업가능



## effect(side effect)

- 리액트는 기본적으로 ui를 랜더링하는 역할, 화면에 무언가를 가져오는 것(이는 특정 이벤트나 상태에 따라 결정)
- jsx코드와 DOM을 평가하고, state와 props을 관리함, ref로 직접 Dom으로 조작하기도 함
- side effect는 애플리케이션에서 일어나는 리엑트의 본래 임무가 아닌 모든 것을 의미
- 브라우저에 저장하거나 http 요청보내는 것, 잠재적인 오류를 해결하는 것이 대표적(화면에 무언가 가져오는 것이 아님)
- side effect는 컴포넌트 평가(함수) 밖에서 일어나야 함
- useeffect(화살표 함수, [dependecies]) 모든 컴포넌트 평가 후에 실행되어야 하는 함수 또는 지정된 의존성이 변경되었을 때 실행하는 함수 , 의존성으로 구성된 배열 - 컴포넌트가 랜더링할 때 실행되는 것이 아님
-  이메일 또는 비밀 번호 키 입력에 대한 응답으로 해당 폼의 유효성 확인하는 기능이므로 사이드 이펙트라 볼 수 있음(응답으로 실행되는 액션이 곧 사이드 이펙트)
- 종속성에 안 넣어야 하는 것 - 새로운 변수나 함수를 종속성 안에서 정의하지 말 것(외부에 있는 거 쓰니까), state는 리액트가 관리해서 안 변하므로 쓰지 말 것, 내장 api나 함수를 추가하지 말 것